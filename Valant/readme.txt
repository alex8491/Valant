Assumptions: 
- The application stores inventory in memory, so the application "starts fresh" each time it starts up and clears all item and notification history.
-  Label and item types are strings, Expiration is a DateTime.
-  Notifications will be handled by another component of the system; they do not need to be publicly exposed for this Web API component.
- Notifications will contain a notification type, reference to the target item, and (while not explicitly required) timestamp of when they were generated. 
- The Web API interface will accept parameters as JSON where appropriate.
- Because item lifetime is in-memory, we can tie the expiration date monitoring to an in-memory process with no additional loss of functionality (all expiration date information's lost when the application closes.) For example, we can use a timer created when the item is added.
- Other commonly-used methods like "ItemExists" are not required at this time.
- Note: There's a small race condition if an item's expiring within miliseconds of being added to the inventory: a notification might not be generated. This could be fixed with locks, preemptively generating an expiration notification if the item's within a small "delta" of being added, or by restructuring the event handling system.

Tests:
- The API Controller is extremely thin and Model objects lack methods to test: as a result InventoryStore is the only class whose methods are covered by unit tests.

Routing: 
MVC-style "/api/{controller}/{action}/{id}" is used.

Security: 
Security is not set up. Windows Authentication is the easiest, followed by Azure Active Director Windows Domain Federation for Windows Authentication. Basic Authentication using ASP.Net  Identity is next easiest, although the downside is transmitting credentials across the internet with each request. OAuth authentication is the most secure, but also the most intensive to set up.

Web API Documention:
The Web API Help File has been autogenerated and can be browsed to by running this project (ctrl+f5) and opening the API tab.


Architecture note: 
 Because this is sample code, everything will remain in the same project. Typically, models / data transfer objects would go into their own, separate project. Data Access would go into its separate project (dbContext, EDMX, handcrafted database interop code, whatever the case). Depending on architectural needs and variety of data sources a Repository project to serve as a facade between data access and your business domain might also be appropriate [i.e. most commonly using implementations of IRepository<TEntity> which exposes Add, Remove, and Update for individual entities and collections [e.g. AddRange, etc.], and exposes the underlying DbContext<TEntity>, stored procedure result,, or other data source as an IQueryable].

Questions: 
- What is the expected behavior if you try to add an item and the label already exists? Until this is answered, it's programmed to return false and fail to process the add command.
- What is the expected behavior if you try to remove an item by label? Until this is answered, it's programmed to return null. 
- What is the expected behavior generating a notification for an item that was already expired when it was added? Until this is answered, a notification is generated at the time the item is added.
- How much detail does a Notification need to contain? Until this is answered, we make the tradeoff of storing a reference to the entire item in the notification at the cost of more rapidly increasing the size of the queue of notifications.
- Are there any space limits to the overall number of notifications/notification histories we need to store? Assuming a queue of 100,000 notifications for now. (Good candidate for a NoSQL database).
- Are there any space limits to the overall number of items we need to store at once? Assuming "no"--if the system starts to take up too many resources to keep track of inventory we'll add more hardware.
- Are there any concurrency requirements? Assuming none; if so we could use async methods in the controller for example. InventoryStore would need to be thread-safe if so.
- Which REST verbs should the API be open to? Assuming post for add and get/post/delete for remove.

