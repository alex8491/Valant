Assumptions: 
- The application stores inventory in memory, so the application "starts fresh" each time it starts up and clears all item and notification history.
-  Label and item types are strings, Expiration is a DateTime.
-  Notifications will be handled by another component of the system; they do not need to be publicly exposed for this Web API component.
- Notifications will contain a notification type, reference to the target item, and (while not explicitly required) timestamp of when they were generated. 
- The Web API interface will accept JSON for the POST request to add an item, and will accept Label as a query string parameter to remove an item.
- Because item lifetime is in-memory, we can tie expiration date monitoring to an in-memory process with no additional loss of functionality (all expiration date information's lost when the application closes.) For example, we can use a timer created when the item is added.
- Other commonly-used Web API methods like "ItemExists" are not required at this time.
- Adding a null item causes the Add function to fail, as does adding an item whose label already exists.
- Note: There's a small race condition if an item's expiring within miliseconds of being added to the inventory: a notification might not be generated. This could be fixed with locks, preemptively generating an expiration notification if the item's within a small "delta" of being added, or by restructuring the event handling system.

Tests:
- The API Controller is extremely thin and Model objects lack methods to test: as a result InventoryStore is the only class whose methods are covered by unit tests.

Routing: 
MVC-style "/api/{controller}/{action}" is used.

Security: 
Security is not set up. Windows Authentication is the easiest, followed by Azure Active Director Windows Domain Federation for Windows Authentication. Basic Authentication using ASP.Net  Identity is next easiest, although the downside is transmitting credentials across the internet with each request. OAuth authentication is the most secure, but also the most intensive to set up.

Web API Documention:
The Web API Help File has been autogenerated and can be browsed to by running this project (ctrl+f5) and opening the API tab.

Logging:
Telemetry is not being added at this time for the sake of simplicity. NLog and Application Insights are my go-to frameworks for lightweight and heavyweight applications respectively; Loupe's a nice integrated telemetry/analytics product for small to midsized enterprises. Flexible--at the end of the day good logging frameworks are mostly interchangeable.

Dependency injection:
Unity/MEF are not being used at this time for the sake of simplicity, though they make complicated object graph creation and dependency injection significantly easier.

Architecture note: 
 Because this is sample code, everything will remain in the same project. Typically, models / data transfer objects would go into their own, separate project. Data Access would go into its separate project (dbContext, EDMX, handcrafted database interop code, whatever the case). Depending on architectural needs and variety of data sources a Repository project to serve as a facade between data access and your business domain might also be appropriate [i.e. most commonly using implementations of IRepository<TEntity> which exposes Add, Remove, and Update for individual entities and collections [e.g. AddRange, etc.], and exposes the underlying DbContext<TEntity>, stored procedure result,, or other data source as an IQueryable].

Questions: 
- What is the expected behavior if you try to add an item and the label already exists? Until this is answered, it's programmed to return false and fail to process the add command.
- What is the expected behavior if you try to remove an item by label and it doesn't exist? Until this is answered, it's programmed to return null. 
- What is the expected behavior generating a notification for an item that was already expired when it was added? Until this is answered, a notification is generated at the time the item is added if it's expired.
- How much detail does a Notification need to contain? Until this is answered, we make the tradeoff of storing a reference to the entire item in the notification at the cost of more rapidly increasing the size of the queue of notifications.
- Are there any space limits to the overall number of notifications/notification histories we need to store? Assuming a queue of 100,000 notifications for now. (Good candidate data source for a NoSQL database).
- Are there any space limits to the overall number of items we need to store at once? Assuming "no"--if the system starts to take up too many resources to keep track of inventory more hardware would be added.
- Are there any concurrency requirements? Assuming none; if so we could use async methods in the controller for example. InventoryStore would need to be thread-safe were this the case.
- Which REST verbs should the API be open to? Assuming post for add and get/post/delete for remove.

